var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
var assert = require('assert');

function getJSON(url) {
  return new Promise((resolve, reject) => { // creates an returns a new promise
    const request = new XMLHttpRequest(); // creates an XMLHTTPRequest object
    request.open("GET", url); // initializes the request 
    request.onload = function () { // on load, registers an event handler that will be called if the server has loaded
      try { // ERROR TYPE 2 server responding with unanticipated data ()   (change get passed in url to  '/data/ninjas.json')
        if (this.status === 200) { // server responded, but use the result only if the server responds with status 200 (everything OK)
          console.log('status: ', this.status);
          resolve(JSON.parse(this.responseText)); // ERROR TYPE 3 invalid json. if it succeeds, resolve the promise with the parsed object (mess with json or use only 'this.response')
        } else {
          console.log('status: ', this.status);
          reject.apply(this.status + " " + this.statusText);
        }
      } catch (e) { // if the server responds with a different status code (other than 200 success) or if there's an exception parsing JSON string, reject the promise
        reject(e.message);
      }
    };
    request.onerror = function () { //  ERROR TYPE 1, error establishing the communication between the server and client (server not running)
      reject(this.status + " " + this.statusText);
    };
    request.send(); // send the request
  });
}

function async (generator) { // function that takes a generator as an argument
  var iterator = generator(); // ITERATOR: calling a GENERATOR creates an ITERATOR through which we control the generator's execution

  function handle(iteratorResult) { // defines  the function that will handle each value generated by the generator
    if (iteratorResult.done) { // stops when the generator is done, remember yielded objects looks like {value: 'Hattori Skulk', done: false}
      return; // stop when generator has no more results
    }

    const iteratorValue = iteratorResult.value; // remember yielded objects looks like {value: 'Hattori Skulk', done: false}

    if (iteratorValue instanceof Promise) { // if produced value is a promise
      iteratorValue.then(result => handle(iterator.next(result))) // IMPORTANT: if the promise succeeds (gets a value), send in the promised value and resume the generator
                   .catch(err => iterator.throw(err)) // if there is an error, throw an error to the generator
    }
  }
  // REMEMBER : calling the iterator's NEXT method requests a new value from the generator
  // by calling the iterator's next method with an argument, we send data back to the generator. The passed in data gets stored in the previously yielded expression (ninjas)

  try {
    handle(iterator.next());
  } catch (e) {
    iterator.throw(e);
  }
}

async (function* () { // passing in a GENERATOR to the function named async. Using asynchronous results, should be able to pause while waiting for results
  try {
    const ninjas = yield getJSON('http://localhost:8080/data/ninjas.json'); // yield keyword produces values one at a time, when the generator is asked for a value
    const missions = yield getJSON(ninjas[0].missionsUrl);
    const missionDescription = yield getJSON(missions[0].detailsUrl);
    console.log(missionDescription);
  } catch (e) {
    console.log('we were not able to get the details, error : ', e);
  }
});